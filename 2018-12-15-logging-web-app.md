# Logging in a Web App

## Logging Providers

A logging provider is a worker that performs logging in its own way. There are logging providers that come out-of-the-box with Asp.NET Core,
and are automatically provided for us when we create a fresh new web application. Because the `Program.cs` generated by the Asp.NET web
application template calls upon `.CreateDefaultBuilders()` we automatically get the console and debug logging providers. They are both
in-memory, on-screen displays. The console logging provider displays messages *on our app itself* when our web app is run in the command
line. The debug logging provider displays messages in the output window in VS.

## Calling Upon Logging in Startup

Since logging has already been set up for us in Program.cs, we can use it from `Startup.cs`.

```csharp
 public class Startup
{
    private ILogger Logger { get; set; }
    private IConfiguration Configuration { get; set; }

    public Startup(IConfiguration configuration, ILogger<Startup> logger)
    {
        Configuration = configuration;
        Logger = logger;
    }

    // This method gets called by the runtime. Use this method to add services to the container.
    // For more information on how to configure your application, visit https://go.microsoft.com/fwlink/?LinkID=398940
    public void ConfigureServices(IServiceCollection services)
    {
        services.AddMvc();
    }

    // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.
    public void Configure(IApplicationBuilder app, IHostingEnvironment env)
    {
        if (env.IsDevelopment())
        {
            Logger.LogInformation("Web App Started - we're in dev");
            app.UseDeveloperExceptionPage();
        }

        app.UseMvc();

        app.Run(async (context) =>
        {
            await context.Response.WriteAsync("Hello World!");
        });
    }
}
```

We would keep an instance of a logger, so we create a property of interface type `ILogger`. We receive the logger from constructor DI,
with `ILogger<Startup>`. Though the `ILogger` property doesn't have the generic parameter, the incoming logger requires it. Since we
set our `ILogger` property equal to the incoming `ILogger<Startup>` in the constructor, we know that `ILogger<Starup>` *is* an `ILogger`.

We then call upon the `.LogInformation()` function to actually create our log. There are other functions of `ILogger` that exists, like
`.LogWarning`, which essentially does the same thing - display the message, but in different ways, which we'll explore later. For now,
we put this kind of logging message (introductory/trivial) in the `if(env.IsDevelopment())` condition. We wouldn't want to use up 
computing resources (albeit relatively small, though they *do* add up) to display many of our log messages when our app is running in
production!

## Viewing the Log Message with the Debug Logging Provider

If we run this app from inside Visual Studio (debug), the logging messages will be shown in the Output window. There will be a lot of
other output messages in there, but if we look carefully, our message is there:

`LoggingFocus.Startup:Information: Web App Started - we're in dev`

Note that this is the debug logger in action, and it's formatted in a specific way. It tells us what class the log is from (including the
namespace), the type or level of log, in our case, `Information` because we called `.LogInformation()`.

## Viewing the Log Message with the Console Logging Provider

If we run this app in the command line, that is, navigate the command prompt to the *project's root*, not `/bin/*`, and then run 
`dotnet run`, we get the following message:

```
info: LoggingFocus.Startup[0]
      Web App Started - we're in dev
```

Notice that it's in a different format than the debug logging provider's output, however, in both, we see our message.

## Logging from a Controller

We can log from a controller, and in order to do that, we also constructor-DI the logger the same way we did it in Startup.

```csharp
 [Route("api/[controller]")]
    public class ValuesController : Controller
    {
        private ILogger Logger { get; set; }
        private IHostingEnvironment HostingEnvironment { get; set; }

        public ValuesController(ILogger<ValuesController> logger, IHostingEnvironment hostingEnvironment)
        {
            Logger = logger;
            HostingEnvironment = hostingEnvironment;
        }

        // GET: api/<controller>
        [HttpGet]
        public IEnumerable<string> Get()
        {
            if (HostingEnvironment.IsDevelopment())
            {
                Logger.LogInformation("Logging from GET /api/values");
            }

            return new string[] { "value1", "value2" };
        }
    }
```

Note that the injected `ILogger<T>` in the constructor requires the generic parameter as it does in Startup. This is to let the logger
know from which class we're logging so that it can display its full qualified path (includes namespace) in the outputs. Note also that
we've obtained the hosting environment so that we would only log when we're in development.

The display in the output window is

`LoggingFocus.Controllers.ValuesController:Information: Logging from GET /api/values`

## Next Steps

So far, we've been able to log to the console and to the output window in VS. We've only been able to "log information" with 
`.LogInformation()`. There are things called log levels that have some level of severity associated with them. The information level is
not considered severe, however, the warning and critical levels are considered more severe. We're able to issue these logs with the
functions `.LogWarning()` and `.LogCritical()`. These log levels do not do anything to how our app functions. They are merely for
log display or writing, however, they are helpful to us when we view those logs. We will get into more details on other considerations
when we log more severe occurrences.

We have yet to figure out how to log to files or even to a database especially when we're in production.

